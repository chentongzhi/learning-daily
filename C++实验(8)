代码10：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
1 1 1 1 1 ********** 2 2 2 2 2 
	原因为：数组名为首元素地址，所以pointer_1、pointer_2初始化后的值相等，访问数组元素的方式为：数组首地址[元素偏移量] == *((首元素地址)+元素偏移量)
	此段代码的实际运行结果如下：
	     
代码11：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
1 2
	原因为：对指针++，指针会往后偏移指向下一个元素的地址
	此段代码的实际运行结果如下：
         
代码12：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
1 2 1 2 3 3
	原因为：对指针++，指针会往后偏移指向下一个元素的地址，*(pointer ++)是先对pointer解引用，再++，而*(++ pointer)是对pointer先++后再进行解引用，*(pointer + 1)不会改变pointer本身的位置
	此段代码的实际运行结果如下：
         
代码13：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
C B A 
	原因为：65536 * 65 + 256 * 66 + 67在内存中存储为01000011 01000010 01000001 00000000（未写成小端存储形式），转换为char*类型后，pointer指向地址为01000011对应着67为’C’的ASCII码，对pointer指针++后指向01000010为B，(pointer + 1)[0] == *(pointer+1)，对应01000001为A
	此段代码的实际运行结果如下：
         
代码14：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
Hello Hello Hello Hello Hello ******* 1 0 0 0 0 1 0
	原因为：a和&a[0]都表示同一个数组的首元素地址，而r存储的为另一个字符串的首元素地址，为不同的两个内存区域，对字符串首元素地址进行cout，会输出整个字符串的内容，p和q的值相等，而r则与他们不相等，“Hello”为r指向区域和p、q不等，“helloworld”为新开辟内存区域，与r也不同
	此段代码的实际运行结果如下：
       
代码15：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
输入月份所对应的英文单词 
	原因为：char*的指针在输出时，会输出对应元素的所有内容，知道’\0’
	此段代码的实际运行结果如下：
        
代码16：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
1 2
	原因为：函数的形参为指针类型，在传实参时传入地址，会修改实参的值
	此段代码的实际运行结果如下：
         
代码17：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
HelloWorld!
	原因为：函数返回值为指针char*，会在输出时输出返回值对应地址，指向的字符串的全部内容 
	此段代码的实际运行结果如下：
         
代码18：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
120 720
	原因为：指向函数的指针：运行时程序代码会存在内存中，函数名是函数代码在内存中的首地址，函数调用的方式就是：函数代码的首地址(实参列表)，因此题目中p和fact功能一致，只是p为指针变量 
	此段代码的实际运行结果如下：
         
代码19：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
         1 1 1 1
	原因为：指针指向对象即把一个对象的首地址存在指针内，使用指针和对象名，均可以访问对象的数据成员和函数成员 
	此段代码的实际运行结果如下：
          
代码20：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
         1 1 1 1
	原因为：指针指向对象即把一个对象的首地址存在指针内，使用指针和对象名，均可以访问对象的数据成员和函数成员 
	此段代码的实际运行结果如下：
         
代码21：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
         1 1 1 1
	原因为：指针指向对象即把一个对象的首地址存在指针内，使用指针和对象名，均可以访问对象的数据成员和函数成员 
	此段代码的实际运行结果如下：
         
代码22：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
         1 1 1 1
	原因为：指针指向对象即把一个对象的首地址存在指针内，使用指针和对象名，均可以访问对象的数据成员和函数成员 
	此段代码的实际运行结果如下：
         
代码23：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
        运行一段时间后，出现死机
	原因为：动态内存申请后不释放，会造成内存泄漏，一旦全部占用会出现死机等 
代码24：此段代码编译时不会出现编译错误。
此段代码的预期运行结果如下：
        运行正常
	原因为：动态内存申请后正常释放，不会造成内存泄漏，运行正常 

